"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var code = " \nxquery version \"1.0-ml\";\n(: this is\n : a \n   \"comment\" :)\nlet $let := <x attr=\"value\">\"test\"<func>function() $var {function()} {$var}</func></x>\nlet $joe:=1\nreturn element element {\n  attribute attribute { 1 },\n  element test { 'a' }, \n  attribute foo { \"bar\" },\n  fn:doc()[ foo/@bar eq $let ],\n  //x }  \n \n(: a more 'evil' test :)\n(: Modified Blakeley example (: with nested comment :) ... :)\ndeclare private function local:declare() {()};\ndeclare private function local:private() {()};\ndeclare private function local:function() {()};\ndeclare private function local:local() {()};\nlet $let := <let>let $let := \"let\"</let>\nreturn element element {\n  attribute attribute { try { xdmp:version() } catch($e) { xdmp:log($e) } },\n  attribute fn:doc { \"bar\" castable as xs:string },\n  element text { text { \"text\" } },\n  fn:doc()[ child::eq/(@bar | attribute::attribute) eq $let ],\n  //fn:doc\n}\n\n\n\nxquery version \"1.0-ml\";\n\n(: Copyright 2006-2010 Mark Logic Corporation. :)\n\n(:\n : Licensed under the Apache License, Version 2.0 (the \"License\");\n : you may not use this file except in compliance with the License.\n : You may obtain a copy of the License at\n :\n :     http://www.apache.org/licenses/LICENSE-2.0\n :\n : Unless required by applicable law or agreed to in writing, software\n : distributed under the License is distributed on an \"AS IS\" BASIS,\n : WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n : See the License for the specific language governing permissions and\n : limitations under the License.\n :)\n\nmodule namespace json = \"http://marklogic.com/json\";\ndeclare default function namespace \"http://www.w3.org/2005/xpath-functions\";\n\n(: Need to backslash escape any double quotes, backslashes, and newlines :)\ndeclare function json:escape($s as xs:string) as xs:string {\n  let $s := replace($s, \"\\\", \"\\\\\")\n  let $s := replace($s, \"\"\"\", \"\\\"\"\")\n  let $s := replace($s, codepoints-to-string((13, 10)), \"\\n\")\n  let $s := replace($s, codepoints-to-string(13), \"\\n\")\n  let $s := replace($s, codepoints-to-string(10), \"\\n\")\n  return $s\n};\n\ndeclare function json:atomize($x as element()) as xs:string {\n  if (count($x/node()) = 0) then 'null'\n  else if ($x/@type = \"number\") then\n    let $castable := $x castable as xs:float or\n                     $x castable as xs:double or\n                     $x castable as xs:decimal\n    return\n    if ($castable) then xs:string($x)\n    else error(concat(\"Not a number: \", xdmp:describe($x)))\n  else if ($x/@type = \"boolean\") then\n    let $castable := $x castable as xs:boolean\n    return\n    if ($castable) then xs:string(xs:boolean($x))\n    else error(concat(\"Not a boolean: \", xdmp:describe($x)))\n  else concat('\"', json:escape($x), '\"')\n};\n\n(: Print the thing that comes after the colon :)\ndeclare function json:print-value($x as element()) as xs:string {\n  if (count($x/*) = 0) then\n    json:atomize($x)\n  else if ($x/@quote = \"true\") then\n    concat('\"', json:escape(xdmp:quote($x/node())), '\"')\n  else\n    string-join(('{',\n      string-join(for $i in $x/* return json:print-name-value($i), \",\"),\n    '}'), \"\")\n};\n\n(: Print the name and value both :)\ndeclare function json:print-name-value($x as element()) as xs:string? {\n  let $name := name($x)\n  let $first-in-array :=\n    count($x/preceding-sibling::*[name(.) = $name]) = 0 and\n    (count($x/following-sibling::*[name(.) = $name]) > 0 or $x/@array = \"true\")\n  let $later-in-array := count($x/preceding-sibling::*[name(.) = $name]) > 0\n  return\n\n  if ($later-in-array) then\n    ()  (: I was handled previously :)\n  else if ($first-in-array) then\n    string-join(('\"', json:escape($name), '\":[',\n      string-join((for $i in ($x, $x/following-sibling::*[name(.) = $name]) return json:print-value($i)), \",\"),\n    ']'), \"\")\n   else\n     string-join(('\"', json:escape($name), '\":', json:print-value($x)), \"\")\n};\n\n(:~\n  Transforms an XML element into a JSON string representation.  See http://json.org.\n  <p/>\n  Sample usage:\n  <pre>\n    xquery version \"1.0-ml\";\n    import module namespace json=\"http://marklogic.com/json\" at \"json.xqy\";\n    json:serialize(&lt;foo&gt;&lt;bar&gt;kid&lt;/bar&gt;&lt;/foo&gt;)\n  </pre>\n  Sample transformations:\n  <pre>\n  &lt;e/&gt; becomes {\"e\":null}\n  &lt;e&gt;text&lt;/e&gt; becomes {\"e\":\"text\"}\n  &lt;e&gt;quote \" escaping&lt;/e&gt; becomes {\"e\":\"quote \\\" escaping\"}\n  &lt;e&gt;backslash \\ escaping&lt;/e&gt; becomes {\"e\":\"backslash \\ escaping\"}\n  &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;b&gt;text2&lt;/b&gt;&lt;/e&gt; becomes {\"e\":{\"a\":\"text1\",\"b\":\"text2\"}}\n  &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;a&gt;text2&lt;/a&gt;&lt;/e&gt; becomes {\"e\":{\"a\":[\"text1\",\"text2\"]}}\n  &lt;e&gt;&lt;a array=\"true\"&gt;text1&lt;/a&gt;&lt;/e&gt; becomes {\"e\":{\"a\":[\"text1\"]}}\n  &lt;e&gt;&lt;a type=\"boolean\"&gt;false&lt;/a&gt;&lt;/e&gt; becomes {\"e\":{\"a\":false}}\n  &lt;e&gt;&lt;a type=\"number\"&gt;123.5&lt;/a&gt;&lt;/e&gt; becomes {\"e\":{\"a\":123.5}}\n  &lt;e quote=\"true\"&gt;&lt;div attrib=\"value\"/&gt;&lt;/e&gt; becomes {\"e\":\"&lt;div attrib=\\\"value\\\"/&gt;\"}\n  </pre>\n  <p/>\n  Namespace URIs are ignored. Namespace prefixes are included in the JSON name.\n  <p/>\n  Attributes are ignored, except for the special attribute @array=\"true\" that\n  indicates the JSON serialization should write the node, even if single, as an\n  array, and the attribute @type that can be set to \"boolean\" or \"number\" to\n  dictate the value should be written as that type (unquoted).  There's also\n  an @quote attribute that when set to true writes the inner content as text\n  rather than as structured JSON, useful for sending some XHTML over the\n  wire.\n  <p/>\n  Text nodes within mixed content are ignored.\n\n  @param $x Element node to convert\n  @return String holding JSON serialized representation of $x\n\n  @author Jason Hunter\n  @version 1.0.1\n    \n  Ported to xquery 1.0-ml; double escaped backslashes in json:escape\n:)\ndeclare function json:serialize($x as element())  as xs:string {\n  string-join(('{', json:print-name-value($x), '}'), \"\")\n};\n    \n";
var _default = code;
exports.default = _default;